// SPDX-License-Identifier: GPL-2.0+

/**
 * \file clients/lcdexec/menu.h
 * \brief Menu system declarations for lcdexec client
 * \author Joris Robijn, Peter Marschall
 * \date 2002-2007
 *
 * \features
 * - Hierarchical menu structures with parent-child relationships
 * - Multiple input parameter types (sliders, rings, numeric, text, IP, checkbox)
 * - Command execution with parameter passing via environment variables
 * - Integration with LCDd server menu protocol
 * - Automatic menu generation and management
 * - Configurable menu entries from configuration files
 * - Memory management for menu structures
 *
 * \usage
 * - Include this header in lcdexec source files
 * - Use menu_read() to load menu configurations
 * - Use menu_sock_send() to register menus with LCDd
 * - Use menu_find_by_id() to locate menu entries
 * - Use menu_free() to clean up menu structures
 *
 * \details This header file declares the menu system used by the lcdexec client
 * for creating interactive command execution interfaces. It defines menu entry
 * types, data structures, and function prototypes for building hierarchical
 * menus with various input parameter types.
 */

#ifndef LCDEXEC_MENU_H
#define LCDEXEC_MENU_H

/** \brief Boolean true value */
#ifndef TRUE
#define TRUE 1
#endif
/** \brief Boolean false value */
#ifndef FALSE
#define FALSE 0
#endif

/**
 * \brief Symbolic names for the types of a MenuEntry.
 *
 * \details Defines the various types of menu entries supported by lcdexec.
 * Uses bit flags to allow for type masking and automatic generation flags.
 */
typedef enum {
	// Unknown MenuEntry type
	MT_UNKNOWN = 0x00,
	// MenuEntry representing a menu
	MT_MENU = 0x10,
	// MenuEntry representing an executable command
	MT_EXEC = 0x20,
	// Mask denoting a parameter of any type
	MT_ARGUMENT = 0x40,
	// BitFlag denoting automatically generated entries
	MT_AUTOMATIC = 0x80,

	// MenuEntry representing a slider parameter
	MT_ARG_SLIDER = 0x41,
	// MenuEntry representing a ring parameter
	MT_ARG_RING = 0x42,
	// MenuEntry representing a numeric input parameter
	MT_ARG_NUMERIC = 0x43,
	// MenuEntry representing a alpha input parameter
	MT_ARG_ALPHA = 0x44,
	// MenuEntry representing a IP input parameter
	MT_ARG_IP = 0x45,
	// MenuEntry representing a checkbox input parameter
	MT_ARG_CHECKBOX = 0x46,
	// MenuEntry to trigger command (ATM autogenerated)
	MT_ARG_ACTION = 0x47,
	// Auto-generated action entry (MT_ARG_ACTION | MT_AUTOMATIC)
	MT_ARG_ACTION_AUTO = 0xC7,
} MenuType;

/**
 * \brief Data structure to hold a menu entry in lcdexec.
 *
 * \details Represents a single menu entry with support for hierarchical
 * menu structures and various input parameter types. Each entry can be
 * a submenu, executable command, or input parameter.
 */
typedef struct menu_entry {
	// Variables necessary for multiple/all types
	// Name of the menu entry (from section name)
	char *name;
	// Visible name of the entry
	char *displayname;
	// Internal ID of the entry
	int id;
	// Type of the entry
	MenuType type;
	// Parent menu entry
	struct menu_entry *parent;
	// Number of child entries
	int numChildren;
	// Subordinate menu entries (for type MT_MENU & MT_EXEC)
	struct menu_entry *children;
	// Next sibling menu entry (for type MT_MENU)
	struct menu_entry *next;

	/**
	 * \brief Type-specific data for menu entries
	 * \details Tagged union containing different structures depending on menu type.
	 * Only one member is valid at a time, determined by the `type` field.
	 */
	union data {
		/**
		 * \brief Command execution data
		 * \details Used when type == MT_EXEC
		 */
		struct exec {
			// Command to execute
			char *command;
			// Feedback flag
			int feedback;
		} exec;

		/**
		 * \brief Slider widget data
		 * \details Used when type == MT_ARG_SLIDER
		 */
		struct slider {
			// Numeric value of slider
			int value;
			// Minimal allowed value
			int minval;
			// Maximal allowed value
			int maxval;
			// Increments/decrement for value
			int stepsize;
			// Label for the min. value
			char *mintext;
			// Label for the max. value
			char *maxtext;
		} slider;

		/**
		 * \brief Ring widget data
		 * \details Used when type == MT_ARG_RING
		 */
		struct ring {
			// Index into list of alternatives
			int value;
			// List of alternatives
			char **strings;
		} ring;

		/**
		 * \brief Numeric input widget data
		 * \details Used when type == MT_ARG_NUMERIC
		 */
		struct numeric {
			// Numeric input value
			int value;
			// Minimal allowed value
			int minval;
			// Maximal allowed value
			int maxval;
		} numeric;

		/**
		 * \brief Alphanumeric text input widget data
		 * \details Used when type == MT_ARG_ALPHA
		 */
		struct alpha {
			// Text value
			char *value;
			// Maximal allowed length
			int minlen;
			// Minimal required length
			int maxlen;
			// Characters allowed in input
			char *allowed;
		} alpha;

		/**
		 * \brief IP address input widget data
		 * \details Used when type == MT_ARG_IP
		 */
		struct ip {
			// IP address value
			char *value;
			// Flag: use IPv6 editing logic
			int v6;
		} ip;

		/**
		 * \brief Checkbox widget data
		 * \details Used when type == MT_ARG_CHECKBOX
		 */
		struct checkbox {
			// Checkbox value
			int value;
			// Flag for tristate chechboxes
			int allow_gray;
			// Replacement strings for each value
			char *map[3];
		} checkbox;
	} data;
} MenuEntry;

/**
 * \brief Read and parse menu configuration from config file.
 * \param parent Parent menu entry (NULL for root menu)
 * \param name Name of the menu section in config file
 * \return Pointer to created menu structure, NULL on error
 */
MenuEntry *menu_read(MenuEntry *parent, const char *name);

/**
 * \brief Send menu structure to LCDd server.
 * \param me Menu entry to send
 * \param parent Parent menu entry
 * \param sock Socket file descriptor for server connection
 * \retval 0 Success: menu sent successfully
 * \retval -1 Error: failed to send menu
 */
int menu_sock_send(MenuEntry *me, MenuEntry *parent, int sock);

/**
 * \brief Find menu entry by its unique ID.
 * \param me Root menu entry to search from
 * \param id Unique identifier to search for
 * \return Pointer to found menu entry, NULL if not found
 */
MenuEntry *menu_find_by_id(MenuEntry *me, int id);

/**
 * \brief Get the command string from an executable menu entry.
 * \param me Menu entry of type MT_EXEC
 * \return Command string, NULL if entry is not executable
 */
const char *menu_command(MenuEntry *me);

/**
 * \brief Free all memory associated with a menu structure.
 * \param me Menu entry to free (frees entire subtree)
 */
void menu_free(MenuEntry *me);

/**
 * \brief Debug function to dump menu structure to stdout.
 * \param me Menu entry to dump (dumps entire subtree)
 */
void menu_dump(MenuEntry *me);

#endif
